# This is my first attempt in a VERY long time at coding for the OHRRPGCE. 
# Things might be a bit messy, but everything here is done in the order I recalled these. 
# Rather; The easiest stuff to code in first. The essentials. I might need help with this later. 
# Without further ado.. [Spazman -- 5/1/2021]
# Rue starting on 2/19/2022

include, xenophage_arrays.hss
include, xenophage_mobs.hss
include, xenophage_globals.hss

script, zoneatpixel, x, y, count=0, begin
	return(zone at spot(x/20, y/20, count))
end

script, wall at pixel, x, y, begin
    x := x / 20
    y := y / 20
    if (read pass block (x, y)) then (
    	return (true)
    )
    else (
    	return (false)
    )
end



script, tickFrameCount, begin
	framecount:=framecount+1
	if (framecount>2147483640) then (framecount:=1)
end


script, updateCamera, begin
	wait for camera
	camera follows slice(player_slice)

end
script, gameloop, begin
	subscript, tickEvent, begin
		# Check inputs and key changes.
		# Check and change object states.
		updateCamera()
		check_keys()
		check_debug_keys()
		fallPlayer()
		handlePlayerJump()
		prepPlayerAnimations()
		if (xgetcurrentdirection(player_slice)==3) then (horiz flip sprite(player_slice,true))
		if (xgetcurrentdirection(player_slice)==1) then (horiz flip sprite(player_slice,false))
		
	end

	subscript, drawEvent, begin
		# Check image states and change image states.
		tickFrameCount()
		replace sprite(player_slice,sprite type:large enemy, get_anim_frame(xgetanimationfirstframe(player_slice),xgetanimationlastframe(player_slice),xgetanimationspeed(player_slice)))
	end

	#set script "gameloop" to run in 1 tick again.
	set timer (timer:gameloop, 1, debug_slowdown, @gameloop)

	tickEvent()
	drawEvent()
end

script, prepPlayerAnimations, begin
	if (xisidle(player_slice) == true) then (
		xsetanimationfirstframe(player_slice,xgetidleanimationfirstframe(player_slice))
		xsetanimationlastframe(player_slice,xgetidleanimationlastframe(player_slice))
	)
	if (xisrunning(player_slice) == true) then (
		xsetanimationfirstframe(player_slice,xgetrunanimationfirstframe(player_slice))
		xsetanimationlastframe(player_slice,xgetrunanimationlastframe(player_slice))
	)
	if (xisjumping(player_slice) == 1) then (
		xsetanimationfirstframe(player_slice,xgetjumpanimationfirstframe(player_slice))
		xsetanimationlastframe(player_slice,xgetjumpanimationlastframe(player_slice))
	)
	if (xisfalling(player_slice) == 1) then (
		xsetanimationfirstframe(player_slice,xgetfallanimationfirstframe(player_slice))
		xsetanimationlastframe(player_slice,xgetfallanimationlastframe(player_slice))
	)
	
	
	
end
script, placeplayerathero, begin
	# TODO: Remove this. This is a terrible system.
	# Let's go back to having the hero just be a spawn point.
	# Currently this is very janky and makes the player slice bounce around all weird.
	put slice(player_slice,hero pixel x(me),hero pixel y(me))
	
end
script, get_anim_frame,first,last,spd, begin
	variable (retval, cell_num)
	retval:=framecount / spd
	cell_num:=retval,mod,((last -- first)+1) # This will return just which cell number, but not the actual sprite to play.
	retval:= first + cell_num
	return (retval)
end

script, check_keys, begin
	if (key is pressed(key:A)) then (
		# try to move left
		movePlayer(left)
	)
	else if (key is pressed(key:D)) then (
		# try to move right
		movePlayer(right)
	)
	else (
		if (xisrunning(player_slice) == 1) then (
			xsetrunning(player_slice,0)
		)
	)
	if (key is pressed(key:Space)) then (
		# try to jump
			launchPlayerJump()
				
	)
end

script, sliceisoncollision,sl, useparent=false,begin
	if (useparent==true) then (
		return (wallatpixel(slice x(sl)+slice x(slice parent(sl)),slice y(sl)+slice y(slice parent(sl))))
	)
	else (
		return (wallatpixel(slice x(sl),slice y(sl)))
	)
end

script, sliceisonslope,sl, useparent=false,begin
	variable (retval)
	if (useparent==true) then (
		retval:=zoneatpixel(slice x(sl)+slice x(slice parent(sl)),slice y(sl)+slice y(slice parent(sl)))
	)
	else (
		retval:=zoneatpixel(slice x(sl),slice y(sl))
	)
	if (retval==2) then (
		return (true)
	)
	else (
		return (false)
	)
end


script, launchPlayerJump, begin
	# This just checks to see if you _can_ jump, and then puts you in jumping mode.
	variable (grounded)
	variable (onslope)
	grounded:=sliceisoncollision(getCollider(player_slice,down),true)
	onslope:=sliceisonslope(getCollider(player_slice,4),true)

	if (grounded==true || onslope==true) then (
		if (xisjumping(player_slice) == 0 && xisfalling(player_slice) == 0) then (
			xsetcurrentjumphangtime(player_slice,0)
			xsetjumping(player_slice,1)
			xsetfalling(player_slice,0)
			)
	)
end

script, handlePlayerJump, begin
	variable (headbonk)

		if (xisJumping(player_slice) == 1 && xisfalling(player_slice) == 0) then (
		
			headbonk:=sliceisoncollision(getCollider(player_slice,up),true)
		
			if (xgetcurrentjumphangtime(player_slice) < xgetmaxjumphangtime(player_slice)) then (
				put slice(player_slice,slice x(player_slice) slice y(player_slice)--xgetjumpspeed(player_slice))
			)


			if (xgetcurrentjumphangtime(player_slice) >= xgetmaxjumphangtime(player_slice)) then (

				xsetjumping(player_slice,0)
				xsetfalling(player_slice,1)
			)

			if (headbonk == True) then (
				xsetjumping(player_slice,0)
				xsetfalling(player_slice,1)
			)
			xsetcurrentjumphangtime(player_slice,xgetcurrentjumphangtime(player_slice)+1)
		)
end

script, fallPlayer, begin
	variable (grounded)
	variable (onslope)
	variable (lowslope)
	variable (backslope)
	
	if (xisjumping(player_slice) == 0) then (
		grounded:=sliceisoncollision(getCollider(player_slice,down),true)
		onslope:=sliceisonslope(getCollider(player_slice,4),true)
		lowslope:=sliceisonslope(getCollider(player_slice,down),true)
		if (xgetcurrentdirection(player_slice) == 1) then (backslope:=sliceisonslope(getCollider(player_slice,left),true))
		if (xgetcurrentdirection(player_slice) == 3) then (backslope:=sliceisonslope(getCollider(player_slice,right),true))

		lowslope:=sliceisonslope(getCollider(player_slice,down),true)
		
		if (grounded == false && onslope == false) then (
				put slice(player_slice,slice x(player_slice),slice y(player_slice)+xgetfallspeed(player_slice))
				
				if (lowslope == true || backslope == true) then (xsetfalling(player_slice,0))
				if (lowslope == false && backslope == false) then (xsetfalling(player_slice,1))
						
		)
		else (
			xsetfalling(player_slice,0)
		)
	)
end

script, movePlayer, dir, amount=4,begin
 	variable (leftCollider)
	variable (rightCollider)
 	variable (upCollider)
 	variable (downCollider)
 	variable (ymod)
 	leftCollider:=getCollider(player_slice,left)
	rightCollider:=getCollider(player_slice,right)
	upCollider:=getCollider(player_slice,up)
 	downCollider:=getCollider(player_slice,down)

 	ymod:=0
	xsetcurrentdirection(player_slice,dir)
 	ymod:=checkSlopes()
 	put slice(player_slice,slice x(player_slice), slice y(player_slice)+ymod)
 	if (dir == left) then(
		if (sliceisoncollision(leftCollider,true) == false) then (
			put slice(player_slice,slice x(player_slice)--amount, slice y(player_slice))
			xsetrunning(player_slice,1)
		)
	)

	if (dir == right) then(
		if (sliceisoncollision(rightCollider,true) == false) then (
			put slice(player_slice,slice x(player_slice)+amount, slice y(player_slice))
			xsetrunning(player_slice,1)
		)
	)
end

script, checkSlopes, begin
	# It aint clean, it aint perfect, but here's some slopes.
 	variable (leftCollider)
 	variable (rightCollider)
 	variable (upCollider)
 	variable (downCollider)
 	variable (slopeCollider)
 	variable (zonecheck)
 	
 	leftCollider:=getCollider(player_slice,left)
	rightCollider:=getCollider(player_slice,right)
	upCollider:=getCollider(player_slice,up)
 	downCollider:=getCollider(player_slice,down)
 	slopeCollider:=getCollider(player_slice,4)
	
	if (sliceisonslope(slopeCollider,true) == true) then (
		if (xgetcurrentdirection(player_slice) == 1) then (
			if (sliceisoncollision(rightCollider,true) == true) then (
				return (0--slopeoffset)
				break
			)
			if (sliceisoncollision(rightCollider,true) == false) then (
				return (0--slopeoffset)
				break
			)
			if (sliceisoncollision(downCollider,true) == true) then (
				return (slopeoffset)
				break
			)
			if (sliceisoncollision(downCollider,true) == false) then (
				return (slopeoffset)
				break
			)

		)
		if (xgetcurrentdirection(player_slice) == 3) then (
			if (sliceisoncollision(leftCollider,true) == true) then (
				return (0--slopeoffset)
				break
			)
			if (sliceisoncollision(leftCollider,true) == false) then (
				return (0--slopeoffset)
				break
			)
			if (sliceisoncollision(downCollider,true) == true) then (
				return (slopeoffset)
				break
			)
			if (sliceisoncollision(downCollider,true) == false) then (
				return (slopeoffset)
				break
			)

		)
	)	
end
script, check_debug_keys, begin
	if (key is pressed(key:Esc)) then (
		game over
	)
	if (key is pressed(key:Shift) && key is pressed(key:A)) then (
		$1 = "Animation Frame: %d"
		string sprintf(0, 1, get_anim_frame(xgetanimationfirstframe(player_slice),xgetanimationlastframe(player_slice),xgetanimationspeed(player_slice)))
		show string (0)
	)

	  if (key is pressed(key:Shift) && key is pressed(key:G)) then (
		$1 = "Player is on ground: %d"
		string sprintf(0, 1, sliceisoncollision(getCollider(player_slice,down),true))
    	show string (0)
	 )
	if (key is pressed(key:Shift) && key is pressed(key:J)) then (
		$1 = "Player is jumping: %d"
		string sprintf(0, 1, xisjumping(player_slice))
		show string (0)
	)
	if (key is pressed(key:Shift) && key is pressed(key:F)) then (
		$1 = "Player is falling: %d"
		string sprintf(0, 1, xisjumping(player_slice))
		show string (0)
	)
	if (key is pressed(key:Shift) && key is pressed(key:R)) then (
		$1 = "Player is running: %d"
		string sprintf(0, 1, xisrunning(player_slice))
		show string (0)
	)

	if (key is pressed(key:Shift) && key is pressed(key:I)) then (
		$1 = "Player is idle: %d"
		string sprintf(0, 1, xisidle(player_slice))

		show string (0)
	)
	
	if (key is pressed(key:Shift) && key is pressed(key:Z)) then (
		$1 = "Zone at position: %d"
		show string (0)
	)
	
	if (key is pressed(key:Shift) && key is pressed(key:N)) then (
		show no value
	)
	if (new keypress(key:Left Bracket)) then (
		$1 = "Debug slowdown decreased: %d"
		debug_slowdown:=debug_slowdown--1 
		if (debug_slowdown < 1) then (debug_slowdown:=1)
		string sprintf(0, 1, debug_slowdown)
		show string (0)
	)
	if (new keypress(key:Right Bracket)) then (
		$1 = "Debug slowdown increased: %d"
		debug_slowdown:=debug_slowdown+1 
		string sprintf(0, 1, debug_slowdown)
		show string (0)
	)

end

plotscript, defnewgame, begin
	gameloaded:=0
	ob_size:=setupArrayDefinitions()
	initiateMobs()
	debug_slowdown:=1
	framecount:=1
	init mouse
	suspend player
	#start the game loop
	slopeoffset:=8
	wait(1)
	create_player() # this actually sets player_slice
	createMobCollider(player_slice)
	placeplayerathero()
	gameloop()
end
